///////////////////////////////////////////////////////////
//  SelectQuery.cs
//  Implementation of the Class SelectQuery
//  Generated by Enterprise Architect
//  Created on:      04-Jan-2007 21:41:43
//  Original author: Marcelo
///////////////////////////////////////////////////////////



using System.Collections.Generic;
using Iris.Runtime.Core.Expressions;
using System;
using Iris.Runtime.Core.ParserEngine.ParserObjects;
namespace Iris.Runtime.Core.ParserObjects
{
  [Serializable]
  public class SelectQuery : BaseParserObject, ISelectQuery
  {

    private List<string> groupBy;

    private string restriction;
    private Expression where;
    public Expression Where
    {
      get
      {
        return where;
      }
      set
      {
        where = value;
      }
    }

    private List<string> orderBy;

    public List<string> OrderBy
    {
      get { return orderBy; }
      set { orderBy = value; }
    }
    private List<string> columns;

    public List<string> Columns
    {
      get { return columns; }
    }


    private FromList fromClause;

    public FromList FromClause
    {
      get { return fromClause; }
    }

    private List<FromList> joinChain;

    public List<FromList> JoinChain
    {
      get { return joinChain; }
    }


    public SelectQuery()
    {
      groupBy = new List<string>();
      orderBy = new List<string>();
      columns = new List<string>();
      joinChain = new List<FromList>();
      fromClause = new FromList("",null);
      union = null;
    }

    public List<string> GroupBy
    {
      get
      {
        return groupBy;
      }
    }

    private Expression having;
    public Expression Having
    {
      get
      {
        return having;
      }
      set
      {
        having = value;
      }
    }

    public string Restriction
    {
      get
      {
        return restriction;
      }
      set
      {
        restriction = value;
      }
    }



    private SelectQuery union;

    public SelectQuery Union
    {
      get { return union; }
      set { union = value; }
    }

    private string unionType;

    public string UnionType
    {
      get { return unionType; }
      set { unionType = value; }
    }



    public override string GetText()
    {
      string select = "SELECT "+restriction;
      foreach (string column in Columns)
      {
        select += " " + column + ",";
      }
      select = select.Substring(0, select.Length - 1);
      select += "\r\n   FROM " + fromClause.GetText();
      foreach (FromList join in JoinChain)
      {
        select += "\r\n      " + join.GetText();
      }

      if(where != null)
        select += "\r\n   WHERE " + where.GetText();

      AddClause(ref select, groupBy, " GROUP BY ");

      if(having != null)
        select += "\r\n   HAVING " + Having.GetText() + " ";

      AddClause(ref select, orderBy, " ORDER BY ");


      if (!string.IsNullOrEmpty(unionType))
      {
        select += "\r\n   " + unionType + "\r\n   " + union.GetText();
      }

      return StringUtils.FormatSpaces(select);
    }

    private static void AddClause(ref string select, List<string> l, string clause)
    {
      string clauseItems = "";
      foreach (string item in l)
      {
        clauseItems += item + ", ";
      }
      if (!string.IsNullOrEmpty(clauseItems))
      {
        clauseItems = clauseItems.Substring(0, clauseItems.Length - 2);
        clauseItems = clause + clauseItems;
        select += "\r\n   "+clauseItems;
      }
    }

    public override void Clear()
    {
      base.Clear();
      groupBy.Clear();
      having = null;
      restriction = "";
      where = null;
      orderBy.Clear();
      columns.Clear();
      fromClause.Members.Clear();
      joinChain.Clear();
      union = null;
      unionType = "";
    }

    public string GetMainTableName()
    {
      string result = "";
      if ((fromClause != null) && (fromClause.Members.Count > 0))
      {
        result = fromClause.Members[0].ToString();
      }
      return result;
    }
  }//end SelectQuery

}//end namespace Parser